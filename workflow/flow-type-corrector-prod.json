{
  "name": "Flow Type Corrector",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "flowtype-check",
        "responseMode": "responseNode",
        "options": {
          "binaryPropertyName": "data"
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        0,
        -176
      ],
      "id": "5ddf2c77-4f77-4acf-ba69-9096140efdcc",
      "name": "Webhook",
      "webhookId": "b89374e7-960f-4235-96c8-a1537d7af181"
    },
    {
      "parameters": {
        "binaryPropertyName": "={{ Object.keys($binary)[0] }}",
        "options": {
          "headerRow": true
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        224,
        -176
      ],
      "id": "bb6943c1-9632-4def-a573-a9aaf083e03e",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "options": {
          "fileName": "corrected.csv",
          "headerRow": true
        }
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        4160,
        -176
      ],
      "id": "ceba19c7-4447-42a3-87bc-2302d21a8739",
      "name": "Convert to File"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=FORMAT: Return ONLY a JSON object with a single key \"output\" whose value is a JSON ARRAY of EXACTLY {{ $json.expectedCount }} objects.\nThe \"output\" value must be a REAL JSON array (e.g., \"output\": [ {...}, {...} ]) \u2014 do NOT put the array inside a string.\nNo preamble, no markdown, no code fences, no extra keys.\n\nEXAMPLES \u2014 INPUT \u2192 EXPECTED OUTPUT\n(do not return these; they are just examples)\n\n<Examples>\n  <Example>\n    <UserInput>\n      Name=\"SH-5991:My Fancy App community sites 3.1 upgrade\", Link=\"https://tasktop-demo.atlassian.net/browse/SH-5991\", Flow Item Type=\"Feature\", Type=\"Story\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"9\", Close=\"Oct 8, 2025\", Notes=\"\"\n    </UserInput>\n    <AgentOutput>\n      Name=\"SH-5991:My Fancy App community sites 3.1 upgrade\", Link=\"https://tasktop-demo.atlassian.net/browse/SH-5991\", Flow Item Type=\"Feature\", Type=\"Story\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"9\", Close=\"Oct 8, 2025\", Notes=\"\"\n    </AgentOutput>\n  </Example>\n\n  <Example>\n    <UserInput>\n      Name=\"DOC-123:Create technical documentation for API integration\", Link=\"https://tasktop-demo.atlassian.net/browse/DOC-123\", Flow Item Type=\"Feature\", Type=\"Documentation\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"5\", Close=\"Oct 7, 2025\", Notes=\"\"\n    </UserInput>\n    <AgentOutput>\n      Name=\"DOC-123:Create technical documentation for API integration\", Link=\"https://tasktop-demo.atlassian.net/browse/DOC-123\", Flow Item Type=\"Supporting\", Type=\"Documentation\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"5\", Close=\"Oct 7, 2025\", Notes=\"Corrected from Feature to Supporting: Documentation supports other work but doesn't deliver direct customer value\"\n    </AgentOutput>\n  </Example>\n\n  <Example>\n    <UserInput>\n      Name=\"PERF-002:Optimize database queries for user dashboard\", Link=\"https://tasktop-demo.atlassian.net/browse/PERF-002\", Flow Item Type=\"Feature\", Type=\"Performance\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"3\", Close=\"Oct 6, 2025\", Notes=\"\"\n    </UserInput>\n    <AgentOutput>\n      Name=\"PERF-002:Optimize database queries for user dashboard\", Link=\"https://tasktop-demo.atlassian.net/browse/PERF-002\", Flow Item Type=\"Debt\", Type=\"Performance\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"3\", Close=\"Oct 6, 2025\", Notes=\"Corrected from Feature to Debt: Performance optimization improves system performance without delivering new customer functionality\"\n    </AgentOutput>\n  </Example>\n\n  <Example>\n    <UserInput>\n      Name=\"SH-4928:Review third party libraries for new versions (3.3)\", Link=\"https://tasktop-demo.atlassian.net/browse/SH-4928\", Flow Item Type=\"Risk\", Type=\"Security Issue\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"8\", Close=\"Oct 9, 2025\", Notes=\"\"\n    </UserInput>\n    <AgentOutput>\n      Name=\"SH-4928:Review third party libraries for new versions (3.3)\", Link=\"https://tasktop-demo.atlassian.net/browse/SH-4928\", Flow Item Type=\"Risk\", Type=\"Security Issue\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"8\", Close=\"Oct 9, 2025\", Notes=\"\"\n    </AgentOutput>\n  </Example>\n\n  <Example>\n    <UserInput>\n      Name=\"BUG-1234:Fix login error when password contains special characters\", Link=\"https://tasktop-demo.atlassian.net/browse/BUG-1234\", Flow Item Type=\"Defect\", Type=\"Bug\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"2\", Close=\"Oct 4, 2025\", Notes=\"\"\n    </UserInput>\n    <AgentOutput>\n      Name=\"BUG-1234:Fix login error when password contains special characters\", Link=\"https://tasktop-demo.atlassian.net/browse/BUG-1234\", Flow Item Type=\"Defect\", Type=\"Bug\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"2\", Close=\"Oct 4, 2025\", Notes=\"\"\n    </AgentOutput>\n  </Example>\n</Examples>\n\n--------------------\nNow classify the real data below.\n\nINSTRUCTIONS:\n- Keep all non-Flow fields exactly as input.\n- Only change \u201cFlow Item Type\u201d if clearly misclassified, using one of:\n  Feature, Defect, Debt, Risk, Supporting\n- When confident the label is correct, leave Notes = \"\".\n- When you change a label, give a concise rationale in Notes.\n- Use exactly these keys in each object: \"index\", \"Flow Item Type\", \"Notes\".\n- Do NOT output any schema or schema-like object.\n\nOUTPUT REQUIREMENTS:\n- Return a single JSON object with one key: \"output\".\n- \"output\" MUST be a JSON array (not a string) with EXACTLY {{ $json.expectedCount }} objects.\n- Maintain the same order as input (index 0..{{ $json.expectedCount - 1 }}).\n- Each array element must have exactly these keys:\n  - \"index\": number (the __localIndex of the input row)\n  - \"Flow Item Type\": one of [Feature, Defect, Debt, Risk, Supporting]\n  - \"Notes\": string (\"\" if unchanged)\n\n--------------------\nNow analyze and correct the following real data rows:\n{{ JSON.stringify($json.rows) }}\n\nOUTPUT EXACTLY:\n{\"output\":[{\"index\":0,\"Flow Item Type\":\"...\",\"Notes\":\"...\"}, ... ]}\nDo NOT wrap the array in a string (no escaped quotes).\nNo code fences. No prose. No extra keys.\n",
        "options": {
          "systemMessage": "You are a Flow Type Corrector.\n\nReturn data **instances**, not a schema. Never output keys like \"type\", \"items\", \"properties\", or \"required\". \nYour reply must be ONLY a JSON array with exactly N objects. No wrapper object, no prose, no code fences.\n\nEach object MUST have exactly:\n- \"index\": integer (row's local index starting at 0)\n- \"Flow Item Type\": one of [\"Feature\",\"Defect\",\"Debt\",\"Risk\",\"Supporting\"]\n- \"Notes\": string (empty \"\" if unchanged; one-sentence rationale if changed)\n\nRules of thumb:\n- bug/issue/crash/error/fix/broken \u2192 Defect\n- security/vulnerability/CVE/unauthorized \u2192 Risk\n- refactor/cleanup/upgrade deps/tech debt/performance tuning \u2192 Debt\n- docs/readme/tutorial/build/CI/config/chore supporting others \u2192 Supporting\n- otherwise \u2192 Feature (if clearly a feature)\n\nIf <60% confident, keep the original type and leave Notes = \"\".\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        1344,
        -304
      ],
      "id": "5a4a4eca-75c5-4f60-9678-7dde5e76c092",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1",
          "mode": "list",
          "cachedResultName": "gpt-4.1"
        },
        "options": {
          "maxTokens": 8000,
          "responseFormat": "json_object",
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1344,
        -80
      ],
      "id": "924098cc-d12e-4e65-9007-1b2ab35f79e2",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "A9pszMi0FsBkgtV3",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "binary",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "text/csv"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        4384,
        -176
      ],
      "id": "ab6500e0-1344-4441-bb38-4ba5ef9b3017",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        3040,
        -176
      ],
      "id": "9e1e5f4c-df56-4072-a389-5f15078e0fee",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "const chunkSize = 40;  // keep 40; this will work with the lean output\n\nconst items = $input.all(); // each CSV row as an item\nconst out = [];\nfor (let i = 0; i < items.length; i += chunkSize) {\n  const slice = items.slice(i, i + chunkSize).map((it, j) => {\n    const row = { ...it.json };\n    row.__index = i + j;              // global index for later merge\n    row.__localIndex = j;             // 0..chunkSize-1 (batch-local)\n    return row;\n  });\n  out.push({ json: { rows: slice, expectedCount: slice.length } });\n}\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        672,
        -176
      ],
      "id": "84ca46a2-1f08-493d-99f5-c55c1045c13e",
      "name": "Chunker"
    },
    {
      "parameters": {
        "jsCode": "// Auto-inserted debug gate\nconst g = this.getWorkflowStaticData('global');\nconst raw = ($json.DEBUG ?? g.DEBUG ?? $env.DEBUG ?? '').toString().toLowerCase();\nconst DEBUG = ['1','true','yes','on'].includes(raw) || (raw === 'true') || (raw === true);\nif (!DEBUG) {\n  // fast path: do nothing/log nothing, pass input along\n  return $input.all();\n}\n\nconst batches = $input.all(); // one item per batch\nconst totalRows = batches.reduce((s,it)=> s + ((it.json.rows||[]).length), 0);\nconst firstSize = (batches[0]?.json.rows||[]).length;\nconsole.log('TAP3 after Chunker \u2192 batches =', batches.length, 'rows_total =', totalRows, 'first_batch_size =', firstSize);\nreturn batches;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        896,
        -176
      ],
      "id": "b1942cb7-7051-4f09-be99-fe949286fccc",
      "name": "Chunk Debug",
      "executeOnce": true,
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Auto-inserted debug gate\nconst g = this.getWorkflowStaticData('global');\nconst raw = ($json.DEBUG ?? g.DEBUG ?? $env.DEBUG ?? '').toString().toLowerCase();\nconst DEBUG = ['1','true','yes','on'].includes(raw) || (raw === 'true') || (raw === true);\nif (!DEBUG) {\n  // fast path: do nothing/log nothing, pass input along\n  return $input.all();\n}\n\nconst merged = $input.all();\nfunction getRows(it){ return it.json?.rows ?? []; }\nfunction getCorr(it){\n  const j=it.json;\n  if (Array.isArray(j?.output)) return j.output;\n  if (Array.isArray(j?.response?.output)) return j.response.output;\n  if (Array.isArray(j?.corrections)) return j.corrections;\n  try { const p = JSON.parse(j?.output ?? j?.response ?? 'null'); return Array.isArray(p?.output)?p.output:Array.isArray(p)?p:[]; } catch { return []; }\n}\nlet rowsHist={}, corrHist={};\nfor (const it of merged){\n  const rc=getRows(it).length, cc=getCorr(it).length;\n  rowsHist[rc]=(rowsHist[rc]||0)+1;\n  corrHist[cc]=(corrHist[cc]||0)+1;\n}\nconsole.log(' rows_per_batch_hist =', rowsHist, ' corr_per_batch_hist =', corrHist);\nreturn merged;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3264,
        -176
      ],
      "id": "ad3939f9-fcc8-4bbc-88be-f964f62fc78d",
      "name": "Merge Debug",
      "executeOnce": true,
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Run Once for All Items = ON\nconst merged = $input.all();   // ~125 items (one per batch)\nconst out = [];\n\nfunction getCorrections(obj) {\n  // Try common shapes (parsed, nested, or raw stringified)\n  if (Array.isArray(obj?.output)) return obj.output;\n  if (Array.isArray(obj?.response?.output)) return obj.response.output;\n  if (Array.isArray(obj?.corrections)) return obj.corrections;\n\n  const raw = obj?.output ?? obj?.response ?? obj?.text;\n  if (typeof raw === 'string') {\n    try {\n      const parsed = JSON.parse(raw);\n      if (Array.isArray(parsed?.output)) return parsed.output;\n      if (Array.isArray(parsed)) return parsed;\n    } catch (_) {}\n  }\n  return [];\n}\n\nfor (const item of merged) {\n  const rows = item.json.rows || [];                 // original 40 rows for this batch\n  const corrections = getCorrections(item.json);     // AI suggestions for this batch\n\n  // index \u2192 correction map (correction.index must match row's local index)\n  const byIdx = new Map();\n  for (const c of corrections) {\n    const k = Number(c?.index);\n    if (Number.isFinite(k)) byIdx.set(k, c);\n  }\n\n  // Expand back to one item per original row, applying corrections\n  for (let j = 0; j < rows.length; j++) {\n    const r = rows[j];\n    const c = byIdx.get(j);\n    const o = { ...r };\n\n    // apply fields you allow the AI to change\n    if (c?.[\"Flow Item Type\"]) o[\"Flow Item Type\"] = c[\"Flow Item Type\"];\n    if (typeof c?.[\"Notes\"] === \"string\") o[\"Notes\"] = c[\"Notes\"];\n\n    // cleanup helper fields if present\n    delete o.__localIndex;\n    delete o.__index;\n    delete o.__batch;\n\n    out.push({ json: o });\n  }\n}\n\nreturn out;   // expect ~5000 items\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3488,
        -176
      ],
      "id": "f12ec666-a448-4f86-a5f4-9377df31e88e",
      "name": "Apply Corrections (Expand)"
    },
    {
      "parameters": {
        "jsCode": "// Auto-inserted debug gate\nconst g = this.getWorkflowStaticData('global');\nconst raw = ($json.DEBUG ?? g.DEBUG ?? $env.DEBUG ?? '').toString().toLowerCase();\nconst DEBUG = ['1','true','yes','on'].includes(raw) || (raw === 'true') || (raw === true);\nif (!DEBUG) {\n  // fast path: do nothing/log nothing, pass input along\n  return $input.all();\n}\n\nconst items = $input.all();\nconsole.log('TAP7 after Expand \u2192 rows =', items.length);\nreturn items;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3712,
        -176
      ],
      "id": "28fe53f8-fc3a-4dc3-b667-bce2a62bf31b",
      "name": "Apply Corrections Debug",
      "executeOnce": true,
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Auto-inserted debug gate\nconst g = this.getWorkflowStaticData('global');\nconst raw = ($json.DEBUG ?? g.DEBUG ?? $env.DEBUG ?? '').toString().toLowerCase();\nconst DEBUG = ['1','true','yes','on'].includes(raw) || (raw === 'true') || (raw === true);\nif (!DEBUG) {\n  // fast path: do nothing/log nothing, pass input along\n  return $input.all();\n}\n\nconst items = $input.all();\nconsole.log('TAP2 after Extract \u2192 rows =', items.length);\nreturn items;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        448,
        -176
      ],
      "id": "03287cc5-c147-47db-8266-ed80bce30cb4",
      "name": "Extract from File Debug",
      "executeOnce": true,
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Auto-inserted debug gate\nconst g = this.getWorkflowStaticData('global');\nconst raw = ($json.DEBUG ?? g.DEBUG ?? $env.DEBUG ?? '').toString().toLowerCase();\nconst DEBUG = ['1','true','yes','on'].includes(raw) || (raw === 'true') || (raw === true);\nif (!DEBUG) {\n  // fast path: do nothing/log nothing, pass input along\n  return $input.all();\n}\n\nconst items = $input.all();\nconsole.log('TAP4 after AI \u2192 batches =', items.length);\nreturn items;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2816,
        -304
      ],
      "id": "0ba99f70-42c9-44f3-8dc9-7f847515a494",
      "name": "Post AI Debug",
      "executeOnce": true,
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Ensure \"Notes\" exists on every row and lock column order for CSV\nconst items = $input.all();\n\n// 1) guarantee Notes is present\nfor (const it of items) {\n  if (!Object.prototype.hasOwnProperty.call(it.json, 'Notes')) it.json.Notes = \"\";\n}\n\n// 2) choose column order from the first item (after we forced Notes)\n//    -> this keeps a stable header and prevents Notes from dropping\nconst cols = Object.keys(items[0]?.json ?? {});\n\n// 3) re-emit rows with exactly these columns in this order\nconst normalized = items.map(it => {\n  const row = {};\n  for (const c of cols) row[c] = it.json[c] ?? \"\";\n  return { json: row };\n});\n\nreturn normalized;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3936,
        -176
      ],
      "id": "53aa037a-389d-4af0-997d-fe9a1847b3b5",
      "name": "Schema Enforcer",
      "executeOnce": true
    },
    {
      "parameters": {
        "jsCode": "// Auto-inserted debug gate\nconst g = this.getWorkflowStaticData('global');\nconst raw = ($json.DEBUG ?? g.DEBUG ?? $env.DEBUG ?? '').toString().toLowerCase();\nconst DEBUG = ['1','true','yes','on'].includes(raw) || (raw === 'true') || (raw === true);\nif (!DEBUG) {\n  // fast path: do nothing/log nothing, pass input along\n  return $input.all();\n}\n\n// Run Once for All Items = ON\nconst items = $input.all();\n\nfunction correctionsFrom(j) {\n  // common shapes\n  if (Array.isArray(j?.output)) return j.output;\n  if (Array.isArray(j?.response?.output)) return j.response.output;\n  if (Array.isArray(j?.corrections)) return j.corrections;\n\n  // null/undefined \u2192 no corrections\n  if (j?.output == null || j?.response == null) return [];\n\n  // stringified\n  const raw = j?.output ?? j?.response ?? j?.text;\n  if (typeof raw === 'string') {\n    try {\n      const p = JSON.parse(raw);\n      if (Array.isArray(p?.output)) return p.output;\n      if (Array.isArray(p)) return p;\n    } catch {}\n  }\n  return [];\n}\n\nconst counts = items.map(it => correctionsFrom(it.json).length);\nconst total = counts.reduce((a,b)=>a+b,0);\nconsole.log('per-batch counts =', counts, 'total =', total);\nreturn items;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2592,
        -304
      ],
      "id": "3dd40e23-f81c-40bf-95df-048b53c525af",
      "name": "temp debug",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Auto-inserted debug gate\nconst g = this.getWorkflowStaticData('global');\nconst raw = ($json.DEBUG ?? g.DEBUG ?? $env.DEBUG ?? '').toString().toLowerCase();\nconst DEBUG = ['1','true','yes','on'].includes(raw) || (raw === 'true') || (raw === true);\nif (!DEBUG) {\n  // fast path: do nothing/log nothing, pass input along\n  return $input.all();\n}\n\nconst it = $input.all()[0]?.json || {};\nconsole.log('expectedCount =', it.expectedCount, 'rows.length =', (it.rows||[]).length);\nreturn $input.all();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        -304
      ],
      "id": "4d7bb22a-e186-4223-ba34-7892aa22b094",
      "name": "Expected Count Debug",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Auto-inserted debug gate\nconst g = this.getWorkflowStaticData('global');\nconst raw = ($json.DEBUG ?? g.DEBUG ?? $env.DEBUG ?? '').toString().toLowerCase();\nconst DEBUG = ['1','true','yes','on'].includes(raw) || (raw === 'true') || (raw === true);\nif (!DEBUG) {\n  // fast path: do nothing/log nothing, pass input along\n  return $input.all();\n}\n\nconst items = $input.all();\nconst s = JSON.stringify(items[0]?.json).slice(0, 500);\nconsole.log('RAW MODEL OUT (first 500 chars):', s);\nreturn items;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2368,
        -304
      ],
      "id": "49603fed-15f4-4ae2-a424-9eb53dfdcaec",
      "name": "Parser Off Debug",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Auto-inserted debug gate\nconst g = this.getWorkflowStaticData('global');\nconst raw = ($json.DEBUG ?? g.DEBUG ?? $env.DEBUG ?? '').toString().toLowerCase();\nconst DEBUG = ['1','true','yes','on'].includes(raw) || (raw === 'true') || (raw === true);\nif (!DEBUG) {\n  // fast path: do nothing/log nothing, pass input along\n  return $input.all();\n}\n\nconst batches = $input.all(); // one item per batch\n\nfunction tryParse(x) {\n  try { return typeof x === 'string' ? JSON.parse(x) : x; }\n  catch { return null; }\n}\n\nfor (let i = 0; i < batches.length; i++) {\n  const raw = batches[i].json;\n\n  // stringify sample for the console\n  const snippet = JSON.stringify(raw).slice(0, 800);\n  console.log(`RAW[b${i}] first 800 chars:`, snippet);\n\n  const parsed = tryParse(raw);\n  const isArray = Array.isArray(parsed);\n  const wrappedArray = Array.isArray(parsed?.output) ? true : false;\n\n  const looksSchema =\n    !!parsed && typeof parsed === 'object' &&\n    (\n      Object.prototype.hasOwnProperty.call(parsed, 'type') ||\n      Object.prototype.hasOwnProperty.call(parsed, 'items') ||\n      Object.prototype.hasOwnProperty.call(parsed, 'properties') ||\n      (parsed.output && typeof parsed.output === 'object' &&\n       (parsed.output.type || parsed.output.items || parsed.output.properties))\n    );\n\n  let arrLen = null, firstKeys = null;\n  if (isArray) {\n    arrLen = parsed.length;\n    if (parsed[0] && typeof parsed[0] === 'object') {\n      firstKeys = Object.keys(parsed[0]).sort();\n    }\n  } else if (wrappedArray) {\n    arrLen = parsed.output.length;\n    if (parsed.output[0] && typeof parsed.output[0] === 'object') {\n      firstKeys = Object.keys(parsed.output[0]).sort();\n    }\n  }\n\n  console.log(`DIAG[b${i}] isArray=${isArray} wrappedArray=${wrappedArray} looksSchema=${looksSchema} len=${arrLen} firstKeys=${JSON.stringify(firstKeys)}`);\n}\n\n// pass-through so downstream can still run if needed\nreturn batches;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2144,
        -304
      ],
      "id": "0d3c6423-d0f9-40d6-bf90-1ac86c22dbea",
      "name": "Bulk Look",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Auto-inserted debug gate\nconst g = this.getWorkflowStaticData('global');\nconst raw = ($json.DEBUG ?? g.DEBUG ?? $env.DEBUG ?? '').toString().toLowerCase();\nconst DEBUG = ['1','true','yes','on'].includes(raw) || (raw === 'true') || (raw === true);\nif (!DEBUG) {\n  // fast path: do nothing/log nothing, pass input along\n  return $input.all();\n}\n\nconst batches = $input.all();\n\nfunction parse(x){ return typeof x==='string' ? JSON.parse(x) : x; }\nconst allowed = new Set(['Feature','Defect','Debt','Risk','Supporting']);\n\nfor (let b=0;b<batches.length;b++){\n  let raw; try { raw = parse(batches[b].json); } catch(e){ console.log(`SOP DIAG [b${b}] -> parse_error`, String(e)); continue; }\n\n  const arr = Array.isArray(raw?.output) ? raw.output : null;\n  if (!arr) { console.log(`SOP DIAG [b${b}] -> shape mismatch. topKeys=`, raw && Object.keys(raw)); continue; }\n\n  let bad=null;\n  for (let i=0;i<arr.length;i++){\n    const it = arr[i];\n    const keys = Object.keys(it).sort().join('|');\n    if (keys !== 'Flow Item Type|Notes|index') { bad={i,why:'extra/missing keys',keys}; break; }\n    if (!Number.isInteger(it.index)) { bad={i,why:'index not integer',val:it.index}; break; }\n    const fit = String(it['Flow Item Type']).trim();\n    if (!allowed.has(fit)) { bad={i,why:'Flow Item Type not in enum',val:fit}; break; }\n    if (typeof it.Notes !== 'string') { bad={i,why:'Notes not string',val:it.Notes}; break; }\n  }\n\n  console.log(`SOP DIAG [b${b}] -> ok=${!bad} len=${arr.length} firstKeys=${arr[0]&&Object.keys(arr[0]).sort()}`);\n  if (bad) console.log('  offending item:', bad, 'item=', arr[bad.i]);\n}\nreturn batches;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1920,
        -304
      ],
      "id": "986917d6-b652-4834-8b9d-6d53f0925573",
      "name": "Debug",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Run Once for All Items = ON\nconst batches = $input.all(); // one item per batch from the Agent\n\nfunction parseMaybe(x){ try { return typeof x==='string' ? JSON.parse(x) : x; } catch { return null; } }\n\nfunction extractArray(payload) {\n  // payload may be string or object; handle common shapes:\n  const j = parseMaybe(payload);\n  if (!j) return [];\n\n  // Bare array\n  if (Array.isArray(j)) return j;\n\n  // { output: [...] }\n  if (Array.isArray(j?.output)) return j.output;\n\n  // { output: \"<stringified array or object>\" }\n  if (typeof j?.output === 'string') {\n    const inner = parseMaybe(j.output);\n    if (Array.isArray(inner)) return inner;            // {output:\"[...]\"}\n    if (Array.isArray(inner?.output)) return inner.output; // {output:\"{\\\"output\\\":[...]}\"}\n  }\n\n  // Stringified bare array/object\n  if (typeof j === 'string') {\n    const k = parseMaybe(j);\n    if (Array.isArray(k)) return k;\n    if (Array.isArray(k?.output)) return k.output;\n  }\n\n  return [];\n}\n\nfunction sanitizeItem(o) {\n  const out = {};\n  out.index = Number.isInteger(o?.index) ? o.index : parseInt(o?.index ?? -1, 10);\n  out[\"Flow Item Type\"] = String(o?.[\"Flow Item Type\"] ?? \"\").trim();\n  out.Notes = typeof o?.Notes === \"string\" ? o.Notes : \"\";\n  return out;\n}\n\nconst normalized = batches.map((it) => {\n  const arr = extractArray(it.json).map(sanitizeItem);\n  // Optional: enforce EXACT length if model slipped\n  const expected = it.json?.expectedCount ?? it.json?.ExpectedCount ?? arr.length;\n  if (Number.isInteger(expected) && expected > 0 && arr.length !== expected) {\n    // pad or trim to expected length with no-op items\n    const pad = i => ({ index: i, \"Flow Item Type\": \"Feature\", Notes: \"\" });\n    if (arr.length < expected) {\n      for (let i = arr.length; i < expected; i++) arr.push(pad(i));\n    } else {\n      arr.length = expected;\n    }\n  }\n  return { json: { output: arr } };\n});\n\nconsole.log('Coerce \u2192 per-batch lengths:', normalized.map(n => n.json.output.length));\nreturn normalized;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1696,
        -304
      ],
      "id": "7302b501-895f-4b47-a7d1-072cceda0499",
      "name": "Coerce to SOP Shape",
      "executeOnce": true
    },
    {
      "parameters": {
        "jsCode": "// Compact stats using Notes\u2260\"\" as the reclassification signal.\n// Input: many items (each row) with at least:\n//   - \"Flow Item Type\"  (current/corrected)\n//   - \"Notes\"           (non-empty means reclassified)\n\nconst classes = [\"Feature\",\"Defect\",\"Debt\",\"Risk\",\"Supporting\"];\nconst rows = items.map(i => i.json);\n\nconst total = rows.length;\nlet reclass = 0;\n\nconst counts_after = Object.fromEntries(classes.map(c => [c, 0]));\n\nfor (const r of rows) {\n  const after = r[\"Flow Item Type\"] || \"\";\n  if (classes.includes(after)) counts_after[after]++;\n\n  const notes = (r.Notes ?? \"\").toString().trim();\n  if (notes.length > 0) reclass++;\n}\n\nconst percents_after = Object.fromEntries(\n  classes.map(c => [c, total ? +(100 * (counts_after[c] || 0) / total).toFixed(2) : 0])\n);\n\nreturn [{\n  json: {\n    total_rows: total,\n    reclassified_count: reclass,\n    reclassified_percent: total ? +(100 * reclass / total).toFixed(2) : 0,\n    counts_after,\n    percents_after\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        432,
        32
      ],
      "id": "d0d30ba6-ce8e-4f32-a325-c58d630df734",
      "name": "Before Stats"
    },
    {
      "parameters": {
        "jsCode": "// Compact stats using Notes\u2260\"\" as the reclassification signal.\n// Input: many items (each row) with at least:\n//   - \"Flow Item Type\"  (current/corrected)\n//   - \"Notes\"           (non-empty means reclassified)\n\nconst classes = [\"Feature\",\"Defect\",\"Debt\",\"Risk\",\"Supporting\"];\nconst rows = items.map(i => i.json);\n\nconst total = rows.length;\nlet reclass = 0;\n\nconst counts_after = Object.fromEntries(classes.map(c => [c, 0]));\n\nfor (const r of rows) {\n  const after = r[\"Flow Item Type\"] || \"\";\n  if (classes.includes(after)) counts_after[after]++;\n\n  const notes = (r.Notes ?? \"\").toString().trim();\n  if (notes.length > 0) reclass++;\n}\n\nconst percents_after = Object.fromEntries(\n  classes.map(c => [c, total ? +(100 * (counts_after[c] || 0) / total).toFixed(2) : 0])\n);\n\nreturn [{\n  json: {\n    total_rows: total,\n    reclassified_count: reclass,\n    reclassified_percent: total ? +(100 * reclass / total).toFixed(2) : 0,\n    counts_after,\n    percents_after\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4176,
        112
      ],
      "id": "f0078dac-fb7d-4b7a-9b07-917a307a2b9f",
      "name": "After Stats"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Extract from File Debug",
            "type": "main",
            "index": 0
          },
          {
            "node": "Before Stats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to File": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Coerce to SOP Shape",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Merge Debug",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunker": {
      "main": [
        [
          {
            "node": "Chunk Debug",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunk Debug": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          },
          {
            "node": "Expected Count Debug",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Debug": {
      "main": [
        [
          {
            "node": "Apply Corrections (Expand)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply Corrections (Expand)": {
      "main": [
        [
          {
            "node": "Apply Corrections Debug",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply Corrections Debug": {
      "main": [
        [
          {
            "node": "Schema Enforcer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File Debug": {
      "main": [
        [
          {
            "node": "Chunker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Post AI Debug": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Schema Enforcer": {
      "main": [
        [
          {
            "node": "Convert to File",
            "type": "main",
            "index": 0
          },
          {
            "node": "After Stats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "temp debug": {
      "main": [
        [
          {
            "node": "Post AI Debug",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Expected Count Debug": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parser Off Debug": {
      "main": [
        [
          {
            "node": "temp debug",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Bulk Look": {
      "main": [
        [
          {
            "node": "Parser Off Debug",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug": {
      "main": [
        [
          {
            "node": "Bulk Look",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Coerce to SOP Shape": {
      "main": [
        [
          {
            "node": "Debug",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1e49c7e8-5e51-4370-9c28-d1c45b1d652f",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "4d09beae58bf58ca12a79f1e639a6b3111e0f8c6534a92d11a420f807d4f5ecc"
  },
  "id": "MpI3Heu1ZWczMRcu",
  "tags": []
}