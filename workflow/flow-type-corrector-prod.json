{
  "name": "Flow Type Corrector",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "flowtype-check",
        "responseMode": "responseNode",
        "options": {
          "binaryPropertyName": "data"
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -1120,
        220
      ],
      "id": "2ed285f2-d743-4bd5-824e-c38596a0152c",
      "name": "Webhook",
      "webhookId": "b89374e7-960f-4235-96c8-a1537d7af181"
    },
    {
      "parameters": {
        "binaryPropertyName": "={{ Object.keys($binary)[0] }}",
        "options": {
          "headerRow": true
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -896,
        220
      ],
      "id": "abb4ee05-093d-483b-82a7-56c71ba12f74",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "options": {
          "fileName": "corrected.csv",
          "headerRow": true
        }
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        1024,
        28
      ],
      "id": "fbdf9225-03b7-441c-9237-04ecf357eb4a",
      "name": "Convert to File"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=FORMAT: Return ONLY a JSON object with a single key \"output\" whose value is a JSON ARRAY of EXACTLY {{ $json.expectedCount }} objects.\nThe \"output\" value must be a REAL JSON array (e.g., \"output\": [ {...}, {...} ]) â€” do NOT put the array inside a string.\nNo preamble, no markdown, no code fences, no extra keys.\n\nEXAMPLES â€” INPUT â†’ EXPECTED OUTPUT\n(do not return these; they are just examples)\n\n<Examples>\n  <Example>\n    <UserInput>\n      Name=\"SH-5991:My Fancy App community sites 3.1 upgrade\", Link=\"https://tasktop-demo.atlassian.net/browse/SH-5991\", Flow Item Type=\"Feature\", Type=\"Story\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"9\", Close=\"Oct 8, 2025\", Notes=\"\"\n    </UserInput>\n    <AgentOutput>\n      Name=\"SH-5991:My Fancy App community sites 3.1 upgrade\", Link=\"https://tasktop-demo.atlassian.net/browse/SH-5991\", Flow Item Type=\"Feature\", Type=\"Story\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"9\", Close=\"Oct 8, 2025\", Notes=\"\"\n    </AgentOutput>\n  </Example>\n\n  <Example>\n    <UserInput>\n      Name=\"DOC-123:Create technical documentation for API integration\", Link=\"https://tasktop-demo.atlassian.net/browse/DOC-123\", Flow Item Type=\"Feature\", Type=\"Documentation\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"5\", Close=\"Oct 7, 2025\", Notes=\"\"\n    </UserInput>\n    <AgentOutput>\n      Name=\"DOC-123:Create technical documentation for API integration\", Link=\"https://tasktop-demo.atlassian.net/browse/DOC-123\", Flow Item Type=\"Supporting\", Type=\"Documentation\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"5\", Close=\"Oct 7, 2025\", Notes=\"Corrected from Feature to Supporting: Documentation supports other work but doesn't deliver direct customer value\"\n    </AgentOutput>\n  </Example>\n\n  <Example>\n    <UserInput>\n      Name=\"PERF-002:Optimize database queries for user dashboard\", Link=\"https://tasktop-demo.atlassian.net/browse/PERF-002\", Flow Item Type=\"Feature\", Type=\"Performance\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"3\", Close=\"Oct 6, 2025\", Notes=\"\"\n    </UserInput>\n    <AgentOutput>\n      Name=\"PERF-002:Optimize database queries for user dashboard\", Link=\"https://tasktop-demo.atlassian.net/browse/PERF-002\", Flow Item Type=\"Debt\", Type=\"Performance\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"3\", Close=\"Oct 6, 2025\", Notes=\"Corrected from Feature to Debt: Performance optimization improves system performance without delivering new customer functionality\"\n    </AgentOutput>\n  </Example>\n\n  <Example>\n    <UserInput>\n      Name=\"SH-4928:Review third party libraries for new versions (3.3)\", Link=\"https://tasktop-demo.atlassian.net/browse/SH-4928\", Flow Item Type=\"Risk\", Type=\"Security Issue\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"8\", Close=\"Oct 9, 2025\", Notes=\"\"\n    </UserInput>\n    <AgentOutput>\n      Name=\"SH-4928:Review third party libraries for new versions (3.3)\", Link=\"https://tasktop-demo.atlassian.net/browse/SH-4928\", Flow Item Type=\"Risk\", Type=\"Security Issue\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"8\", Close=\"Oct 9, 2025\", Notes=\"\"\n    </AgentOutput>\n  </Example>\n\n  <Example>\n    <UserInput>\n      Name=\"BUG-1234:Fix login error when password contains special characters\", Link=\"https://tasktop-demo.atlassian.net/browse/BUG-1234\", Flow Item Type=\"Defect\", Type=\"Bug\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"2\", Close=\"Oct 4, 2025\", Notes=\"\"\n    </UserInput>\n    <AgentOutput>\n      Name=\"BUG-1234:Fix login error when password contains special characters\", Link=\"https://tasktop-demo.atlassian.net/browse/BUG-1234\", Flow Item Type=\"Defect\", Type=\"Bug\", Project=\"SHIELD\", Flow State=\"Done\", Tool State=\"Done\", Age=\"\", Flow Time=\"2\", Close=\"Oct 4, 2025\", Notes=\"\"\n    </AgentOutput>\n  </Example>\n</Examples>\n\n--------------------\nNow classify the real data below.\n\nINSTRUCTIONS:\n- Keep all non-Flow fields exactly as input.\n- Only change â€œFlow Item Typeâ€ if clearly misclassified, using one of:\n  Feature, Defect, Debt, Risk, Supporting\n- When confident the label is correct, leave Notes = \"\".\n- When you change a label, give a concise rationale in Notes.\n- Use exactly these keys in each object: \"index\", \"Flow Item Type\", \"Notes\".\n- Do NOT output any schema or schema-like object.\n\nOUTPUT REQUIREMENTS:\n- Return a single JSON object with one key: \"output\".\n- \"output\" MUST be a JSON array (not a string) with EXACTLY {{ $json.expectedCount }} objects.\n- Maintain the same order as input (index 0..{{ $json.expectedCount - 1 }}).\n- Each array element must have exactly these keys:\n  - \"index\": number (the __localIndex of the input row)\n  - \"Flow Item Type\": one of [Feature, Defect, Debt, Risk, Supporting]\n  - \"Notes\": string (\"\" if unchanged)\n\n--------------------\nNow analyze and correct the following real data rows:\n{{ JSON.stringify($json.rows) }}\n\nOUTPUT EXACTLY:\n{\"output\":[{\"index\":0,\"Flow Item Type\":\"...\",\"Notes\":\"...\"}, ... ]}\nDo NOT wrap the array in a string (no escaped quotes).\nNo code fences. No prose. No extra keys.\n",
        "options": {
          "systemMessage": "You are a Flow Type Corrector.\n\nReturn data **instances**, not a schema. Never output keys like \"type\", \"items\", \"properties\", or \"required\". \nYour reply must be ONLY a JSON array with exactly N objects. No wrapper object, no prose, no code fences.\n\nEach object MUST have exactly:\n- \"index\": integer (row's local index starting at 0)\n- \"Flow Item Type\": one of [\"Feature\",\"Defect\",\"Debt\",\"Risk\",\"Supporting\"]\n- \"Notes\": string (empty \"\" if unchanged; one-sentence rationale if changed)\n\nRules of thumb:\n- bug/issue/crash/error/fix/broken â†’ Defect\n- security/vulnerability/CVE/unauthorized â†’ Risk\n- refactor/cleanup/upgrade deps/tech debt/performance tuning â†’ Debt\n- docs/readme/tutorial/build/CI/config/chore supporting others â†’ Supporting\n- otherwise â†’ Feature (if clearly a feature)\n\nIf <60% confident, keep the original type and leave Notes = \"\".\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -224,
        0
      ],
      "id": "b37c26b2-a442-462e-b2f6-6a5988d71a0d",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1",
          "mode": "list",
          "cachedResultName": "gpt-4.1"
        },
        "options": {
          "maxTokens": 8000,
          "responseFormat": "json_object",
          "temperature": 0.1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -152,
        224
      ],
      "id": "6cf17c74-f180-4f93-9d37-5b892ad9926b",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "A9pszMi0FsBkgtV3",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "binary",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "text/csv"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        1248,
        28
      ],
      "id": "4956c1e6-4751-435f-9eb5-3c9010f80635",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        352,
        124
      ],
      "id": "463504b9-51a7-43b5-87ed-038738b37d09",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "const chunkSize = 40;  // keep 40; this will work with the lean output\n\nconst items = $input.all(); // each CSV row as an item\nconst out = [];\nfor (let i = 0; i < items.length; i += chunkSize) {\n  const slice = items.slice(i, i + chunkSize).map((it, j) => {\n    const row = { ...it.json };\n    row.__index = i + j;              // global index for later merge\n    row.__localIndex = j;             // 0..chunkSize-1 (batch-local)\n    return row;\n  });\n  out.push({ json: { rows: slice, expectedCount: slice.length } });\n}\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -672,
        124
      ],
      "id": "17c2bf8e-1dfb-460d-a5d5-f16d3030a897",
      "name": "Chunker"
    },
    {
      "parameters": {
        "jsCode": "// Run Once for All Items = ON\nconst merged = $input.all();   // ~125 items (one per batch)\nconst out = [];\n\nfunction getCorrections(obj) {\n  // Try common shapes (parsed, nested, or raw stringified)\n  if (Array.isArray(obj?.output)) return obj.output;\n  if (Array.isArray(obj?.response?.output)) return obj.response.output;\n  if (Array.isArray(obj?.corrections)) return obj.corrections;\n\n  const raw = obj?.output ?? obj?.response ?? obj?.text;\n  if (typeof raw === 'string') {\n    try {\n      const parsed = JSON.parse(raw);\n      if (Array.isArray(parsed?.output)) return parsed.output;\n      if (Array.isArray(parsed)) return parsed;\n    } catch (_) {}\n  }\n  return [];\n}\n\nfor (const item of merged) {\n  const rows = item.json.rows || [];                 // original 40 rows for this batch\n  const corrections = getCorrections(item.json);     // AI suggestions for this batch\n\n  // index â†’ correction map (correction.index must match row's local index)\n  const byIdx = new Map();\n  for (const c of corrections) {\n    const k = Number(c?.index);\n    if (Number.isFinite(k)) byIdx.set(k, c);\n  }\n\n  // Expand back to one item per original row, applying corrections\n  for (let j = 0; j < rows.length; j++) {\n    const r = rows[j];\n    const c = byIdx.get(j);\n    const o = { ...r };\n\n    // apply fields you allow the AI to change\n    if (c?.[\"Flow Item Type\"]) o[\"Flow Item Type\"] = c[\"Flow Item Type\"];\n    if (typeof c?.[\"Notes\"] === \"string\") o[\"Notes\"] = c[\"Notes\"];\n\n    // cleanup helper fields if present\n    delete o.__localIndex;\n    delete o.__index;\n    delete o.__batch;\n\n    out.push({ json: o });\n  }\n}\n\nreturn out;   // expect ~5000 items\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        576,
        124
      ],
      "id": "217e94a2-fc44-4c93-b104-0f8c4e872d6d",
      "name": "Apply Corrections (Expand)"
    },
    {
      "parameters": {
        "jsCode": "// Ensure \"Notes\" exists on every row and lock column order for CSV\nconst items = $input.all();\n\n// 1) guarantee Notes is present\nfor (const it of items) {\n  if (!Object.prototype.hasOwnProperty.call(it.json, 'Notes')) it.json.Notes = \"\";\n}\n\n// 2) choose column order from the first item (after we forced Notes)\n//    -> this keeps a stable header and prevents Notes from dropping\nconst cols = Object.keys(items[0]?.json ?? {});\n\n// 3) re-emit rows with exactly these columns in this order\nconst normalized = items.map(it => {\n  const row = {};\n  for (const c of cols) row[c] = it.json[c] ?? \"\";\n  return { json: row };\n});\n\nreturn normalized;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        124
      ],
      "id": "897a7425-cf05-48fe-8d1c-4d18e24a1f8c",
      "name": "Schema Enforcer",
      "executeOnce": true
    },
    {
      "parameters": {
        "jsCode": "// Auto-inserted debug gate\nconst g = this.getWorkflowStaticData('global');\nconst raw = ($json.DEBUG ?? g.DEBUG ?? $env.DEBUG ?? '').toString().toLowerCase();\nconst DEBUG = ['1','true','yes','on'].includes(raw) || (raw === 'true') || (raw === true);\nif (!DEBUG) {\n  // fast path: do nothing/log nothing, pass input along\n  return $input.all();\n}\n\nconst it = $input.all()[0]?.json || {};\nconsole.log('expectedCount =', it.expectedCount, 'rows.length =', (it.rows||[]).length);\nreturn $input.all();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -448,
        0
      ],
      "id": "fbb2a9b3-70da-4cc2-8c80-f4d8ea084353",
      "name": "Expected Count Debug",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Run Once for All Items = ON\nconst batches = $input.all(); // one item per batch from the Agent\n\nfunction parseMaybe(x){ try { return typeof x==='string' ? JSON.parse(x) : x; } catch { return null; } }\n\nfunction extractArray(payload) {\n  // payload may be string or object; handle common shapes:\n  const j = parseMaybe(payload);\n  if (!j) return [];\n\n  // Bare array\n  if (Array.isArray(j)) return j;\n\n  // { output: [...] }\n  if (Array.isArray(j?.output)) return j.output;\n\n  // { output: \"<stringified array or object>\" }\n  if (typeof j?.output === 'string') {\n    const inner = parseMaybe(j.output);\n    if (Array.isArray(inner)) return inner;            // {output:\"[...]\"}\n    if (Array.isArray(inner?.output)) return inner.output; // {output:\"{\\\"output\\\":[...]}\"}\n  }\n\n  // Stringified bare array/object\n  if (typeof j === 'string') {\n    const k = parseMaybe(j);\n    if (Array.isArray(k)) return k;\n    if (Array.isArray(k?.output)) return k.output;\n  }\n\n  return [];\n}\n\nfunction sanitizeItem(o) {\n  const out = {};\n  out.index = Number.isInteger(o?.index) ? o.index : parseInt(o?.index ?? -1, 10);\n  out[\"Flow Item Type\"] = String(o?.[\"Flow Item Type\"] ?? \"\").trim();\n  out.Notes = typeof o?.Notes === \"string\" ? o.Notes : \"\";\n  return out;\n}\n\nconst normalized = batches.map((it) => {\n  const arr = extractArray(it.json).map(sanitizeItem);\n  // Optional: enforce EXACT length if model slipped\n  const expected = it.json?.expectedCount ?? it.json?.ExpectedCount ?? arr.length;\n  if (Number.isInteger(expected) && expected > 0 && arr.length !== expected) {\n    // pad or trim to expected length with no-op items\n    const pad = i => ({ index: i, \"Flow Item Type\": \"Feature\", Notes: \"\" });\n    if (arr.length < expected) {\n      for (let i = arr.length; i < expected; i++) arr.push(pad(i));\n    } else {\n      arr.length = expected;\n    }\n  }\n  return { json: { output: arr } };\n});\n\nconsole.log('Coerce â†’ per-batch lengths:', normalized.map(n => n.json.output.length));\nreturn normalized;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        128,
        0
      ],
      "id": "347e6f75-aebf-49c0-a175-49b728975d33",
      "name": "Coerce to SOP Shape",
      "executeOnce": true
    },
    {
      "parameters": {
        "jsCode": "// Compact stats using Notesâ‰ \"\" as the reclassification signal.\n// Input: many items (each row) with at least:\n//   - \"Flow Item Type\"  (current/corrected)\n//   - \"Notes\"           (non-empty means reclassified)\n\nconst classes = [\"Feature\",\"Defect\",\"Debt\",\"Risk\",\"Supporting\"];\nconst rows = items.map(i => i.json);\n\nconst total = rows.length;\nlet reclass = 0;\n\nconst counts_after = Object.fromEntries(classes.map(c => [c, 0]));\n\nfor (const r of rows) {\n  const after = r[\"Flow Item Type\"] || \"\";\n  if (classes.includes(after)) counts_after[after]++;\n\n  const notes = (r.Notes ?? \"\").toString().trim();\n  if (notes.length > 0) reclass++;\n}\n\nconst percents_after = Object.fromEntries(\n  classes.map(c => [c, total ? +(100 * (counts_after[c] || 0) / total).toFixed(2) : 0])\n);\n\nreturn [{\n  json: {\n    total_rows: total,\n    reclassified_count: reclass,\n    reclassified_percent: total ? +(100 * reclass / total).toFixed(2) : 0,\n    counts_after,\n    percents_after\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -672,
        316
      ],
      "id": "21e10001-afee-4751-ba78-3f4c2c7ba624",
      "name": "Before Stats"
    },
    {
      "parameters": {
        "jsCode": "// Compact stats using Notesâ‰ \"\" as the reclassification signal.\n// Input: many items (each row) with at least:\n//   - \"Flow Item Type\"  (current/corrected)\n//   - \"Notes\"           (non-empty means reclassified)\n\nconst classes = [\"Feature\",\"Defect\",\"Debt\",\"Risk\",\"Supporting\"];\nconst rows = items.map(i => i.json);\n\nconst total = rows.length;\nlet reclass = 0;\n\nconst counts_after = Object.fromEntries(classes.map(c => [c, 0]));\n\nfor (const r of rows) {\n  const after = r[\"Flow Item Type\"] || \"\";\n  if (classes.includes(after)) counts_after[after]++;\n\n  const notes = (r.Notes ?? \"\").toString().trim();\n  if (notes.length > 0) reclass++;\n}\n\nconst percents_after = Object.fromEntries(\n  classes.map(c => [c, total ? +(100 * (counts_after[c] || 0) / total).toFixed(2) : 0])\n);\n\nreturn [{\n  json: {\n    total_rows: total,\n    reclassified_count: reclass,\n    reclassified_percent: total ? +(100 * reclass / total).toFixed(2) : 0,\n    counts_after,\n    percents_after\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1024,
        220
      ],
      "id": "7f1a585d-968c-4b58-95be-136e9dd6b10d",
      "name": "After Stats"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Before Stats",
            "type": "main",
            "index": 0
          },
          {
            "node": "Chunker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to File": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Coerce to SOP Shape",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Apply Corrections (Expand)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunker": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          },
          {
            "node": "Expected Count Debug",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply Corrections (Expand)": {
      "main": [
        [
          {
            "node": "Schema Enforcer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schema Enforcer": {
      "main": [
        [
          {
            "node": "Convert to File",
            "type": "main",
            "index": 0
          },
          {
            "node": "After Stats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Expected Count Debug": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Coerce to SOP Shape": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "0b24fe41-c272-4501-b81f-186a43171fa9",
  "meta": {
    "instanceId": "4d09beae58bf58ca12a79f1e639a6b3111e0f8c6534a92d11a420f807d4f5ecc"
  },
  "id": "p3GxV0tmcy8yvO43",
  "tags": []
}